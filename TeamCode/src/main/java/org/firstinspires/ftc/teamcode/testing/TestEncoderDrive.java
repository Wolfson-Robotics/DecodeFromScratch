package org.firstinspires.ftc.teamcode.testing;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;

/*
This was all generated by Gemini so idk if it will work


AI GENERATED SLOP!!!
 */

@Autonomous(name="TestEncoderDrive")
public class TestEncoderDrive extends LinearOpMode {

    /* Declare OpMode members. */
    private DcMotor         leftFrontDrive;
    private DcMotor         rightFrontDrive;
    private DcMotor         leftRearDrive;
    private DcMotor         rightRearDrive;

    private ElapsedTime     runtime = new ElapsedTime();

    // Mecanum calculations require a distance-to-count for a single wheel.
    static final double     COUNTS_PER_MOTOR_REV    = 537.7 ;    // eg: TETRIX Motor Encoder
    static final double     DRIVE_GEAR_REDUCTION    = 1.0 ;     // No External Gearing.
    static final double     WHEEL_DIAMETER_INCHES   = 4.0944 ;     // For figuring circumference
    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
            (WHEEL_DIAMETER_INCHES * 3.14159265359); // Use better PI approximation
    static final double     DRIVE_SPEED             = 0.6;
    static final double     TURN_SPEED              = 0.5;
    static final double     STRAFE_SPEED            = 0.6; // New constant for strafing

    @Override
    public void runOpMode() {

        // Initialize the drive system variables.
        leftFrontDrive  = hardwareMap.get(DcMotor.class, "lf_drive");
        rightFrontDrive = hardwareMap.get(DcMotor.class, "rf_drive");
        leftRearDrive   = hardwareMap.get(DcMotor.class, "lb_drive");
        rightRearDrive  = hardwareMap.get(DcMotor.class, "rb_drive");

        // The directions for mecanum wheels are often set as an X pattern for movement.
        // This configuration may vary based on your specific wheel/gearbox assembly.
        leftFrontDrive.setDirection(DcMotor.Direction.REVERSE);
        rightFrontDrive.setDirection(DcMotor.Direction.FORWARD);
        leftRearDrive.setDirection(DcMotor.Direction.REVERSE);
        rightRearDrive.setDirection(DcMotor.Direction.FORWARD);

        // Set all motors to run with encoders
        leftFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftRearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightRearDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        leftFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        leftRearDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightRearDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // Send telemetry message to indicate successful Encoder reset
        telemetry.addData("Starting at",  "LF:%7d RF:%7d LR:%7d RR:%7d",
                leftFrontDrive.getCurrentPosition(),
                rightFrontDrive.getCurrentPosition(),
                leftRearDrive.getCurrentPosition(),
                rightRearDrive.getCurrentPosition());
        telemetry.update();

        // Wait for the game to start (driver presses START)
        waitForStart();

        // Step through each leg of the path
        // For Mecanum, we now need to specify forward/strafe/turn distance in inches.
        // A simple way is to define a movement vector (forward, strafe) and a rotation distance.

        // Movement convention for encoderDriveMecanum:
        // forwardInches: positive = forward, negative = backward
        // strafeInches: positive = strafe right, negative = strafe left
        // turnInches: positive = turn clockwise (right), negative = turn counter-clockwise (left)
        // Note: 'turnInches' is a conceptual distance for the two-wheel tank drive it replaces.
        //       Here, it translates to motor power differentials for rotation.

        // S1: Drive Forward for 48 inches (like original)
        encoderDriveMecanum(DRIVE_SPEED, 48, 0, 0, 5.0);

        // S2: Strafe Right for 24 inches (New Mecanum capability)
        encoderDriveMecanum(STRAFE_SPEED, 0, 24, 0, 4.0);

        // S3: Turn Right (clockwise) for 12 "turn-inches"
        encoderDriveMecanum(TURN_SPEED, 0, 0, 12, 4.0);

        // S4: Drive Backward for 24 inches (like original)
        encoderDriveMecanum(DRIVE_SPEED, -24, 0, 0, 4.0);

        telemetry.addData("Path", "Complete");
        telemetry.update();
        sleep(1000);  // pause to display final telemetry message.
    }

    /**
     * Method to perform a relative move for a Mecanum drive, based on encoder counts.
     * This method simplifies the movement to one primary direction (forward/backward, strafe, or turn)
     * by treating the longest travel distance as the primary target for all motors in RUN_TO_POSITION.
     * This is a simplified approach; more complex multi-axis moves would require more advanced odometry/PID.
     */
    public void encoderDriveMecanum(double speed,
                                    double forwardInches, double strafeInches, double turnInches,
                                    double timeoutS) {

        int newLeftFrontTarget, newRightFrontTarget, newLeftRearTarget, newRightRearTarget;

        // Calculate the power components (simplified for primary movement)
        double forward = forwardInches; // Y-axis
        double strafe  = strafeInches;  // X-axis
        double turn    = turnInches;    // Rotation

        // Mecanum Kinematics (Power calculation based on target distances)
        // The signs here determine the resulting movement.
        double leftFrontPower = forward + strafe + turn;
        double rightFrontPower = forward - strafe - turn;
        double leftRearPower = forward - strafe + turn;
        double rightRearPower = forward + strafe - turn;

        // Determine the largest component to normalize speed
        double maxPower = Math.max(Math.abs(leftFrontPower), Math.abs(rightFrontPower));
        maxPower = Math.max(maxPower, Math.abs(leftRearPower));
        maxPower = Math.max(maxPower, Math.abs(rightRearPower));

        if (maxPower > 1.0) {
            leftFrontPower /= maxPower;
            rightFrontPower /= maxPower;
            leftRearPower /= maxPower;
            rightRearPower /= maxPower;
        }

        // Determine the target position for each wheel based on the calculated power and overall distance
        // The total distance moved is approximated by the longest required movement component.
        double maxInches = Math.abs(forwardInches) + Math.abs(strafeInches) + Math.abs(turnInches);

        if (opModeIsActive() && maxInches > 0) { // Only run if there is a desired movement

            // Calculate target positions based on the power ratio * total distance
            newLeftFrontTarget = leftFrontDrive.getCurrentPosition() + (int)(leftFrontPower * maxInches * COUNTS_PER_INCH);
            newRightFrontTarget = rightFrontDrive.getCurrentPosition() + (int)(rightFrontPower * maxInches * COUNTS_PER_INCH);
            newLeftRearTarget = leftRearDrive.getCurrentPosition() + (int)(leftRearPower * maxInches * COUNTS_PER_INCH);
            newRightRearTarget = rightRearDrive.getCurrentPosition() + (int)(rightRearPower * maxInches * COUNTS_PER_INCH);

            // Set Target Position
            leftFrontDrive.setTargetPosition(newLeftFrontTarget);
            rightFrontDrive.setTargetPosition(newRightFrontTarget);
            leftRearDrive.setTargetPosition(newLeftRearTarget);
            rightRearDrive.setTargetPosition(newRightRearTarget);

            // Turn On RUN_TO_POSITION
            leftFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            rightFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            leftRearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            rightRearDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            // reset the timeout time and start motion.
            runtime.reset();
            leftFrontDrive.setPower(Math.abs(leftFrontPower * speed));
            rightFrontDrive.setPower(Math.abs(rightFrontPower * speed));
            leftRearDrive.setPower(Math.abs(leftRearPower * speed));
            rightRearDrive.setPower(Math.abs(rightRearPower * speed));

            // keep looping while we are still active, and there is time left, and at least one motor is running.
            // Using || ensures that the robot attempts to complete the full movement profile.
            while (opModeIsActive() &&
                    (runtime.seconds() < timeoutS) &&
                    (leftFrontDrive.isBusy() || rightFrontDrive.isBusy() || leftRearDrive.isBusy() || rightRearDrive.isBusy())) {

                // Display it for the driver.
                telemetry.addData("Running to",  " LF:%7d RF:%7d LR:%7d RR:%7d",
                        newLeftFrontTarget, newRightFrontTarget, newLeftRearTarget, newRightRearTarget);
                telemetry.addData("Currently at", " LF:%7d RF:%7d LR:%7d RR:%7d",
                        leftFrontDrive.getCurrentPosition(),
                        rightFrontDrive.getCurrentPosition(),
                        leftRearDrive.getCurrentPosition(),
                        rightRearDrive.getCurrentPosition());
                telemetry.update();
            }

            // Stop all motion;
            leftFrontDrive.setPower(0);
            rightFrontDrive.setPower(0);
            leftRearDrive.setPower(0);
            rightRearDrive.setPower(0);

            // Turn off RUN_TO_POSITION
            leftFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            rightFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            leftRearDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            rightRearDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(250);   // optional pause after each move.
        }
    }
}